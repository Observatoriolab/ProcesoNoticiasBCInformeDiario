var A=Object.defineProperty,S=t=>A(t,"__esModule",{value:!0}),R=(t,e)=>{S(t);for(var n in e)A(t,n,{get:e[n],enumerable:!0})},C=(t,e,n)=>{if(!e.has(t))throw TypeError("Cannot "+n)},m=(t,e,n)=>(C(t,e,"read from private field"),n?n.call(t):e.get(t)),x=(t,e,n,r)=>(C(t,e,"write to private field"),r?r.call(t,n):e.set(t,n),n);R(exports,{Cron:()=>E,IntervalBasedCronScheduler:()=>M,TIMEOUT_MAX:()=>I,TimerBasedCronScheduler:()=>N,extractDateElements:()=>b,getDaysBetweenWeekdays:()=>D,getDaysInMonth:()=>T,longTimeout:()=>k,parseCronExpression:()=>j});var g,w,c,v;class M{constructor(t){g.set(this,void 0);w.set(this,void 0);c.set(this,[]);v.set(this,1);x(this,g,t),this.start()}start(){if(m(this,w)!==void 0)throw new Error("Scheduler already started.");x(this,w,setInterval(this.processTasks.bind(this),m(this,g)))}stop(){m(this,w)&&(clearInterval(m(this,w)),x(this,w,void 0))}insertTask(t){const e=m(this,c).findIndex(n=>n.nextExecution.getTime()>t.nextExecution.getTime());m(this,c).splice(e,0,t)}registerTask(t,e,n=!1){const r=m(this,v);return this.insertTask({id:r,cron:t,nextExecution:t.getNextDate(),isOneTimeTask:n,task:e}),x(this,v,m(this,v)+1),r}unregisterTask(t){const e=m(this,c).findIndex(n=>n.id===t);if(e===-1)throw new Error("Task not found.");m(this,c).splice(e,1)}sortTasks(){m(this,c).sort((t,e)=>t.nextExecution.getTime()-e.nextExecution.getTime())}processTasks(){const t=Date.now();let e=!1,n=!1;for(let r=0;r<m(this,c).length;r+=1){const a=m(this,c)[r];if(a.nextExecution.getTime()<=t)a.task(),a.isOneTimeTask?n=!0:(e=!0,a.nextExecution=a.cron.getNextDate());else break}n&&x(this,c,m(this,c).filter(r=>r.nextExecution.getTime()>t)),e&&this.sortTasks()}}g=new WeakMap,w=new WeakMap,c=new WeakMap,v=new WeakMap;const I=2147483647;function k(t,e,n){let r=0;return e>I&&(r=e-I,e=I),n!=null||(n={timeoutId:void 0}),n.timeoutId=setTimeout(()=>{r>0?k(t,r,n):t()},e),n}function b(t){return{second:t.getSeconds(),minute:t.getMinutes(),hour:t.getHours(),day:t.getDate(),month:t.getMonth(),weekday:t.getDay(),year:t.getFullYear()}}function T(t,e){return new Date(t,e+1,0).getDate()}function D(t,e){return t<=e?e-t:6-t+e+1}class N{static setTimeout(t,e){const n=t.getNextDate(),r=n.getTime()-Date.now();return k(e,r)}static setInterval(t,e,n){n!=null||(n={timeoutId:void 0});const{timeoutId:r}=this.setTimeout(t,()=>{e(),this.setInterval(t,e,n)});return n.timeoutId=r,n}static clearTimeoutOrInterval(t){t.timeoutId&&clearTimeout(t.timeoutId)}}class E{constructor({seconds:t,minutes:e,hours:n,days:r,months:a,weekdays:d}){if(!t||t.size===0)throw new Error("There must be at least one allowed second.");if(!e||e.size===0)throw new Error("There must be at least one allowed minute.");if(!n||n.size===0)throw new Error("There must be at least one allowed hour.");if(!a||a.size===0)throw new Error("There must be at least one allowed month.");if((!d||d.size===0)&&(!r||r.size===0))throw new Error("There must be at least one allowed day or weekday.");this.seconds=Array.from(t).sort((s,i)=>s-i),this.minutes=Array.from(e).sort((s,i)=>s-i),this.hours=Array.from(n).sort((s,i)=>s-i),this.days=Array.from(r).sort((s,i)=>s-i),this.months=Array.from(a).sort((s,i)=>s-i),this.weekdays=Array.from(d).sort((s,i)=>s-i);const u=(s,i,h)=>{if(i.some(o=>typeof o!="number"||o%1!==0||o<h.min||o>h.max))throw new Error(`${s} must only consist of integers which are within the range of ${h.min} and ${h.max}`)};u("seconds",this.seconds,{min:0,max:59}),u("minutes",this.minutes,{min:0,max:59}),u("hours",this.hours,{min:0,max:23}),u("days",this.days,{min:1,max:31}),u("months",this.months,{min:0,max:11}),u("weekdays",this.weekdays,{min:0,max:6}),this.reversed={seconds:this.seconds.map(s=>s).reverse(),minutes:this.minutes.map(s=>s).reverse(),hours:this.hours.map(s=>s).reverse(),days:this.days.map(s=>s).reverse(),months:this.months.map(s=>s).reverse(),weekdays:this.weekdays.map(s=>s).reverse()}}findAllowedHour(t,e){return t==="next"?this.hours.find(n=>n>=e):this.reversed.hours.find(n=>n<=e)}findAllowedMinute(t,e){return t==="next"?this.minutes.find(n=>n>=e):this.reversed.minutes.find(n=>n<=e)}findAllowedSecond(t,e){return t==="next"?this.seconds.find(n=>n>e):this.reversed.seconds.find(n=>n<e)}findAllowedTime(t,e){let n=this.findAllowedHour(t,e.hour);if(n!==void 0)if(n===e.hour){let r=this.findAllowedMinute(t,e.minute);if(r!==void 0)if(r===e.minute){const a=this.findAllowedSecond(t,e.second);if(a!==void 0)return{hour:n,minute:r,second:a};if(r=this.findAllowedMinute(t,t==="next"?e.minute+1:e.minute-1),r!==void 0)return{hour:n,minute:r,second:t==="next"?this.seconds[0]:this.reversed.seconds[0]}}else return{hour:n,minute:r,second:t==="next"?this.seconds[0]:this.reversed.seconds[0]};if(n=this.findAllowedHour(t,t==="next"?e.hour+1:e.hour-1),n!==void 0)return{hour:n,minute:t==="next"?this.minutes[0]:this.reversed.minutes[0],second:t==="next"?this.seconds[0]:this.reversed.seconds[0]}}else return{hour:n,minute:t==="next"?this.minutes[0]:this.reversed.minutes[0],second:t==="next"?this.seconds[0]:this.reversed.seconds[0]};return}findAllowedDayInMonth(t,e,n,r){var h,o;if(r<1)throw new Error("startDay must not be smaller than 1.");const a=T(e,n),d=this.days.length!==31,u=this.weekdays.length!==7;if(!d&&!u)return r>a?t==="next"?void 0:a:r;let s;d&&(s=t==="next"?this.days.find(l=>l>=r):this.reversed.days.find(l=>l<=r),s!==void 0&&s>a&&(s=void 0));let i;if(u){const l=new Date(e,n,r).getDay(),y=t==="next"?(h=this.weekdays.find(f=>f>=l))!=null?h:this.weekdays[0]:(o=this.reversed.weekdays.find(f=>f<=l))!=null?o:this.reversed.weekdays[0];if(y!==void 0){const f=t==="next"?D(l,y):D(y,l);i=t==="next"?r+f:r-f,(i>a||i<1)&&(i=void 0)}}return s!==void 0&&i!==void 0?t==="next"?Math.min(s,i):Math.max(s,i):s!==void 0?s:i!==void 0?i:void 0}getNextDate(t=new Date){const e=b(t);let n=e.year,r=this.months.findIndex(d=>d>=e.month);r===-1&&(r=0,n++);const a=this.months.length*5;for(let d=0;d<a;d++){const u=n+Math.floor((r+d)/this.months.length),s=this.months[(r+d)%this.months.length],i=u===e.year&&s===e.month;let h=this.findAllowedDayInMonth("next",u,s,i?e.day:1),o=i&&h===e.day;if(h!==void 0&&o){const l=this.findAllowedTime("next",e);if(l!==void 0)return new Date(u,s,h,l.hour,l.minute,l.second);h=this.findAllowedDayInMonth("next",u,s,h+1),o=!1}if(h!==void 0&&!o)return new Date(u,s,h,this.hours[0],this.minutes[0],this.seconds[0])}throw new Error("No valid next date was found.")}getNextDates(t,e){const n=[];let r;for(let a=0;a<t;a++)r=this.getNextDate(r!=null?r:e),n.push(r);return n}*getNextDatesIterator(t,e){let n;for(;;){if(n=this.getNextDate(t),t=n,e&&e.getTime()<n.getTime())return;yield n}}getPrevDate(t=new Date){const e=b(t);let n=e.year,r=this.reversed.months.findIndex(d=>d<=e.month);r===-1&&(r=0,n--);const a=this.reversed.months.length*5;for(let d=0;d<a;d++){const u=n-Math.floor((r+d)/this.reversed.months.length),s=this.reversed.months[(r+d)%this.reversed.months.length],i=u===e.year&&s===e.month;let h=this.findAllowedDayInMonth("prev",u,s,i?e.day:31),o=i&&h===e.day;if(h!==void 0&&o){const l=this.findAllowedTime("prev",e);if(l!==void 0)return new Date(u,s,h,l.hour,l.minute,l.second);h>1&&(h=this.findAllowedDayInMonth("prev",u,s,h-1),o=!1)}if(h!==void 0&&!o)return new Date(u,s,h,this.reversed.hours[0],this.reversed.minutes[0],this.reversed.seconds[0])}throw new Error("No valid previous date was found.")}getPrevDates(t,e){const n=[];let r;for(let a=0;a<t;a++)r=this.getPrevDate(r!=null?r:e),n.push(r);return n}*getPrevDatesIterator(t,e){let n;for(;;){if(n=this.getPrevDate(t),t=n,e&&e.getTime()>n.getTime())return;yield n}}matchDate(t){const{second:e,minute:n,hour:r,day:a,month:d,weekday:u}=b(t);return this.seconds.indexOf(e)!==-1&&this.minutes.indexOf(n)!==-1&&this.hours.indexOf(r)!==-1&&this.months.indexOf(d)!==-1&&(this.days.indexOf(a)!==-1||this.weekdays.indexOf(u)!==-1)}}const W={min:0,max:59},H={min:0,max:59},$={min:0,max:23},F={min:1,max:31},G={min:1,max:12,aliases:{jan:"1",feb:"2",mar:"3",apr:"4",may:"5",jun:"6",jul:"7",aug:"8",sep:"9",oct:"10",nov:"11",dec:"12"}},O={min:0,max:6,aliases:{"7":"0",sun:"0",mon:"1",tue:"2",wed:"3",thu:"4",fri:"5",sat:"6"}},z={"@yearly":"0 0 1 1 *","@annually":"0 0 1 1 *","@monthly":"0 0 1 1 *","@weekly":"0 0 * * 0","@daily":"0 0 * * *","@hourly":"0 * * * *","@minutely":"* * * * *"};function p(t,e){const n=new Set;if(t==="*"){for(let o=e.min;o<=e.max;o=o+1)n.add(o);return n}const r=t.split(",");if(r.length>1)return r.forEach(o=>{const l=p(o,e);l.forEach(y=>n.add(y))}),n;const a=o=>{var y,f;o=(f=(y=e.aliases)==null?void 0:y[o.toLowerCase()])!=null?f:o;const l=parseInt(o,10);if(Number.isNaN(l))throw new Error(`Failed to parse ${t}: ${o} is NaN.`);if(l<e.min||l>e.max)throw new Error(`Failed to parse ${t}: ${o} is outside of constraint range of ${e.min} - ${e.max}.`);return l},d=/^((([0-9a-zA-Z]+)-([0-9a-zA-Z]+))|\*)(\/([0-9]+))?$/.exec(t);if(d===null)return n.add(a(t)),n;const u=d[1]==="*"?e.min:a(d[3]),s=d[1]==="*"?e.max:a(d[4]);if(u>=s-1)throw new Error(`Failed to parse ${t}: Invalid range (start: ${u}, end: ${s}).`);const i=d[6];let h=1;if(i!==void 0&&(h=parseInt(i,10),Number.isNaN(h)))throw new Error(`Failed to parse step: ${i} is NaN.`);for(let o=u;o<=s;o=o+h)n.add(o);return n}function j(t){var i;if(typeof t!="string")throw new TypeError("Invalid cron expression: must be of type string.");t=(i=z[t.toLowerCase()])!=null?i:t;const e=t.split(" ");if(e.length<5||e.length>6)throw new Error("Invalid cron expression: expected 5 or 6 elements.");const n=e.length===6?e[0]:"0",r=e.length===6?e[1]:e[0],a=e.length===6?e[2]:e[1],d=e.length===6?e[3]:e[2],u=e.length===6?e[4]:e[3],s=e.length===6?e[5]:e[4];return new E({seconds:p(n,W),minutes:p(r,H),hours:p(a,$),days:p(d,F),months:new Set(Array.from(p(u,G)).map(h=>h-1)),weekdays:p(s,O)})}
//# sourceMappingURL=cron-schedule.cjs.min.js.map
